%-*-coding: utf-8-*-

\chapter{Анализ предложенного алгоритма}  \label{chapter3}

\section{Модель и определения}
Прежде всего опишем модель, в которой будут проводиться следующие рассуждения, доказательства лемм и теорем.

Определим \textit{события} в системе. Событиями будем считать:
\begin{itemize}
\item отправку сообщения
\item получение сообщения
\item запуск таймера
\item остановку таймера
\end{itemize}

Будем считать, что событие отправки сообщения происходит до его получения, запуска таймера до его остановки, а также, что события одного участника могут быть линейно упорядоченны.

В итоге мы получили систему на основе событий с полным порядком. В данной системе можно ввести понятие \textit{согласованного среза}[ссылка]. Также введем в данной системе глобальное время. Каждому событию в системе можно сопоставить некоторый глобальный момент времени, причем будем считать, что двум событиям одного участника соответствуют разные моменты времени. Заметим, что все события, которые произошли до некоторого момента времени $t$, образуют согласованный срез. Таким образом, если некоторое утверждение верно для любого среза, то оно также верно и для и для всех событий до момента времени $t$.

Прежде всего, каждый участник имеет состояние, в которое входят следующие переменные соответствующих типов:
\begin{itemize}
\item $leaderChange$ :: \texttt{Bool}
\item $proposed$ :: \texttt{Map (ConfigurationdId, LeaderId, SlotId) Propose}
\item $acceptance$ ::  \texttt{Map SlotId PrepareCertificate}
\item $Log$      :: \texttt{Vector CommitCertificate}
\item $c$          :: \texttt{ConfigurationId}
\item $v$          :: \texttt{LeaderId}
\item $Q$         :: \texttt{Set (PublicKey, Nonce, Signature)}
\item $puzzle$ :: \texttt{Vector TODO}
\item $L$          :: \texttt{PublicKey}
\end{itemize}
Семантическое значение всех переменных можно узнать в предыдущей главе.

Обозначим состояние $i$-го участника в момент времени $t$ как $S_i(t)$, а состояние всей системы $S(t)$. 
$S(t)=\{S_1(t), S_2(t),..., S_{3f+1}(t)\}$. Также введем обозначение $variable^i(t)$ значение переменной $variable$ у участника $i$ в момент времени $t$.
Обозначим состояние $i$-го участника в согласованном срезе $C$ как $S_i(C)$, аналогично $S(C)$ и $variable^i$.
Если $S^i$, $S$ и $variable^i(t)$ используется без указания времени или среза, то предполагается, что $t$ или $C$ ясны из контекста, либо для любых $t$ и $C$.

Будем считать, что честные участники изменяют их состояния согласно описанному алгоритму, в то время как нечестные могут изменять произвольно.

Злые участники \textbf{TODO}.

\textit{Определение.} Будем называть изменение $d$ \textit{оседлым} в слоте $s$, если у как минимум $f+1$ честного участника $acceptance_s$~--- это корректный сертификат согласия для $(c, v, s, d)$.

\textit{Определение.} Будем считать, что честный участник $i$ находится в \textit{состоянии смены лидера}, если $leaderChange^i = True$.

\textit{Определение.} Будем считать, что честный участник $i$ находится в \textit{устойчивом состоянии}, если $leaderChange^i = False$.

\textit{Определение.} Состояние системы $S$ называется \textit{устойчивым состоянием}, если не более $f$ честных участников находятся в состоянии смены лидера. 
%и как минимум $f+1$ честных участников, находящихся в устойчивом состоянии, имеют одинаковое значение $(c^i, v^i)=(c,v)$.

Будем говорить \textit{устойчивое состояние $(c, v)$}, имея ввиду $(c, v)$ из определения.

Если система или участник не находится в устойчивом состоянии, будем говорить, что они находится в \textit{неустойчивом} состоянии.

\section{Базовые свойства}
В данном разделе будут доказаны некоторые базовые свойства, который будут использоваться в дальнейшем.

\textbf{\textit{Свойство 1.}} \textit{Весь жизненный цикл системы разбивается на последовательность времен
$T_0 < T_1 < T_2 < T_3 < ...$, $T_0=0$, где в полуитервалах $[T_{2k}...T_{2k+1})$ система находится в устойчивом состоянии, а в полуинтервалах $[T_{2k+1}...T_{2k+2})$ в неустойчивом.}
Это очевидно следует из того, что количество участников, который находятся в состоянии смены лидера либо не больше $f$, либо больше $f$. $\square$.
\vspace{10pt}

\textbf{\textit{Свойство 2.}} \textit{Значение $(c^i, v^i)$ не убывает со временем.}
Это очевидно следует из того, что на протяжении алгоритма, значения $с$ и $v$ только увеличиваются. $\square$.
\vspace{10pt}

\textbf{\textit{Свойство 3.}} \textit{В любой момент времени не может существовать более одного сертификата согласия с одинаковой тройкой значений $(c, v, s)$, но для разных изменений.} 

Предположим, что существуют два сертификата согласия $\mathcal{P}_1$ и $\mathcal{P}_2$ с одинаковыми $(c, v, s)$, но разыми $d_1$ и $d_2$. 
Обозначим за $A$ множество участников отправивших $Prepare$ сообщения для  $\mathcal{P}_1$ ($|A|=2f+1$), за $B$ ($|B|=2f+1$) сообщения для $\mathcal{P}_2$. $|A \cap B| \ge f+1$, отсюда следует, что в пересечении найдется как минимум один честный участник,  обозначим его за $x$. Получаем, что $x$ отправил два $Prepare$ сообщения с разными $d_1$ и $d_2$, но одинаковыми $(c, v, s)$. Однако, это противоречит проверке 1.1 из раздела \ref{steady-state}. $\square$
\vspace{10pt}

\textbf{\textit{Свойство 4.}} \textit{В каждом устойчивом состоянии существует такой согласованный срез $C$, для которого выполняется, что у всех честных участников, кроме может быть $f$ из них, $s^i$ равны некоторому значению $s$ и $acceptance^i_s$ одинаковы.}

Это очевидно верно для устойчивого состояния $[T_0...T_1)$, срез $C$ можно взять по $T_0$.

Рассмотрим некоторое устойчивое состояние, а также предыдущее ему состояние смены лидера.
Если хотя бы у одного честного участника $i$ значение $leaderChange$ стало $True$, это значит, что он получил сам и отправил другим $\mathcal{W}$. Получая $\mathcal{W}$, участник актуализирует лог вплоть до $s^{*}$ и присваивает $acceptance_{s_P^{*}} := \hat{\mathcal{P}}^{*}$. Если в какой-то момент времени, состояние стало устойчивым, значит у не более чем $f$ честных участников $leaderChange = False$, следовательно, для остальных существовал такой момент времени $t_i$, в который $s^i$ был равен $s^{*}$ и $acceptance_{s_P^{*}}$ равен $\hat{\mathcal{P}}^{*}$. Возьмем эти моменты времени $t_i$ в качестве среза $C$. $\square$

\section{Консистентность алгоритма}
В данном разделе будет дано определение \textit{консистентности} (Consistency)\cite{hybrid-consensus} и доказано, что предложенный алгоритм обладает этим свойством.

Будем считать, что алгоритм обладает свойством \textit{общего префикса}, если в любой момент для любых двух честных участников комитета (возможно одного и того же) $i$ и $j$ выполняется: либо $Log^i$ префикс $Log^j$, либо $Log^j$ префикс $Log^i$. Считаем, что $x$ префиксом самого себя и $\emptyset$ префиксом $x$.

Будем считать, что честный участник удовлетворяет свойству \textit{самоконсистентности}, если выполняется: пусть участник честный во время $t$ и $t' \ge t$, $Log^i$~--- лог в момент времени $t$, $Log'^i$~--- в момент времени $t'$, тогда верно, что $Log^i$ префикс $Log'^i$.

Будем называть алгоритм \textit{консистентным}, если для него выполняется свойство общего префикса и для любого участника выполняется свойство самоконсистентности.
 
Далее будет приведено доказательство консистентности предложенного алгоритма.

\textbf{\textit{Лемма 1.}} \textit{В любой момент времени для любого слота $s$ существует не более одного оседлого изменения $d$.}

Предположим, что существуют два оседлых изменения $d_1$ и $d_2$ в слоте $s$. Рассмотрим сертификат согласия $\mathcal{P}_1$ любого участника для $d_1$ и сертификат согласия $\mathcal{P}_2$ любого участника для $d_2$. Обозначим за $(c_1, v_1)$ значения $c$ и $v$ из первого сертификата, и $(c_2, v_2)$ из второго.

Обозначим за $A$ множество участников отправивших$Prepare$ сообщения для  $\mathcal{P}_1$ ($|A|=2f+1$), за $B$ ($|B|=2f+1$) сообщения для $\mathcal{P}_2$. $|A \cap B| \ge f+1$, отсюда следует, что в пересечении найдется как минимум один честный участник,  обозначим его за $x$. Получаем, что $x$ отправил два $Prepare$ сообщения с разными $d_1$ и $d_2$: одно с $(c_1, v_1, s)$ и второе с $(c_2, v_2, s)$.

Допустим, что $c_1 = c_2$ и  $v_1 = v_2$. Тогда получаем противоречие со Свойством 3.

Допустим теперь, что $c_1 < c_2$. Это бы значило, что $x$ между отправками $Prepare$ сообщений должен был перейти в другую конфигурацию. Сделать он это может только добавив в свой лог $\mathcal{C}$ с $d_{rec}$, тем самым увеличив свое значение слота, но тогда бы он не смог отправить второе $Prepare$ сообщение для того же самого $s$, что и первое. Аналогично для случая $c_2 < c_1$.

Допустим теперь, что $c_1=c_2=c$ и $v_1 < v_2$. Пусть $\mathcal{P}_1$ стал оседлым первым в момент времени  $T$. Пусть на данный момент в последнем участнике, принявшим $\mathcal{P}_1$ значение конфигурации и номера лидера были $(c, v^i) < (c, v_2)$, тогда в следующем устойчивом состоянии $d_1$ должно быть применено в лог изменений как минимум у $f+1$ участников, и соотвественно, их значение слота будет больше $s$, что не позволит им отправить $Prepare$ сообщение для $s$. $\square$
\vspace{10pt}

\textbf{\textit{Лемма 2.}} \textit{Если изменение $d$ стало оседлым в $s$ в устойчивое состояние то $(c, v)$ сертификата согласия строго больше $(c^j, v^j)$ сертификата согласия для неоседлого в слоте $s$ изменения $d'$ ($d \ne d'$).}

Если изменение стало оседлым в устойчивом состоянии, то это значит, что как минимум у $f+1$ честного участника $(c^i, v^i)$ равно значению в сертификате $(c, v)$. И так как $(c^i, v^i)$ увеличивается со временем по Свойству 2, все предыдущие сертификаты согласия имеют $(c^j, v^j)$ меньше либо равное $(c^i, v^i)$, но $(c^j, v^j)$ не может быть равно $(c^i, v^i)$ так как это бы противоречило Свойству 3.
$\square$
\vspace{10pt}

\textbf{\textit{Лемма 3.}} \textit{Если в некоторый момент времени $T$ для слота $s$ существует некоторое оседлое изменение $d$, то данное изменение в конечном счете окажется в логе применения всех честных участников в слоте $s$.}

Пускай не теряя общности, $t \le T$~--- это первый момент времени, в который $d$ стало оседлым в $s$.

Пусть в момент времени $t$ система находится в устойчивом состоянии. Чтобы оставаться в нем, лидер  должен за некоторое ограниченное время отправить как минимум $f+1$ честным участникам $\mathcal{C}$ для $s, d$, иначе же система перейдет в состояние смены лидера. Отметим, что у лидера нет другой опции, кроме как уведомить минимум $f+1$ честных участников о $\mathcal{С}$ для $s, d$, потому что $f+1$ честный участник ожидает только его, так как они получили $\mathcal{P}$ и отправили свое $Commit$ сообщение.

Если существуют как минимум $f+1$ честных участников, которые имеют $\mathcal{C}^i$ для слота не меньшего чем $s$, тогда очередная процедура реконфигурации распространит среди всех честных участников некоторый $\mathcal{C}'$ со слотом большим $s$. Таким образом, честные участники, для которых неизвестен $\mathcal{С}$ для $s, d$, смогут получить его в процедуре актуализации логов на шаге 3.3 реконфигурации.

Теперь рассмотрим случай, когда в момент времени $T$ система находится в состоянии смены лидера ($T_{2k+1} \le T < T_{2k+2}$). Не теряя общности, возьмем наименьшее такое $T$, для которого все еще выполняется $T_{2k+1} \le T < T_{2k+2}$.

Если $T= T_{2k+1}$, то есть изменение $d$ было оседлым в $s$ с $\mathcal{P}$ для $(c, v)$ до начала состояния смены лидера, тогда в сертификате $\mathcal{W}$, полученном для следующего устойчивого состояния, $\mathcal{P}^{*}$ неизбежно будет для $c, v, s, d$, так как для формирования $Election$ сообщения необходимо как миниум $2f+1$ $LeaderChange$ сообщение, следовательно, обязательно присутствие как минимум одного $\mathcal{P}$ для $c, v, s, d$. Также принимаем во внимание, что по Лемме 1 не может существовать другого оседлого значения, и по Лемме 2 любой другой сертификат имеет $(c^j, v^j)$ меньшее, чем $(c, v)$. С другой стороны, система не перейдет в новое устойчивое состояние до тех пор, пока как минимум $f+1$ честный участник не получит $\mathcal{C}$ для $s, d$. Учитывая то, что среди $f+1$ лидеров, которым отправят $LeaderChange$, будет как минимум один честный, рано или поздно это произойдет. А далее по уже описанному случаю.

Если же  $T > T_{2k+1}$, это означает, что $d$ могло стать оседлым только на шаге 3.5 процедуры смены лидера. Тогда в следующем устойчивом состоянии как минимум $f+1$ честный участник будет иметь сертификат $acceptance_s = \mathcal{P}^{*}$, и следовательно, как минимум $f+1$ честный будут иметь $\mathcal{C}$ для $s, d$. А далее доказательство для уже описанного выше случая.
$\square$
\vspace{10pt}

\textit{Следствие из Леммы 3.} Если хотя бы один честный участник имеет сертификат применения $\mathcal{C}$ для изменения $d$, то  изменение $d$ неизбежно окажется в логе применения всех честных участников в слоте $s$. 

Это следует из того, что как минимум $f+1$ честных участнкиков, отправивших $Commit$ сообщение для $\mathcal{C}$, имеют сертификат согласия для $d$ и $s$. $\square$
\vspace{10pt}

\textbf{Теорема.} \textit{В любой момент времени логи честных участников консистентны.}

Предположим, что в некоторый момент времени существуют различные участники $i$ и $j$, такие что, существует $s$, для которого выполняется, что изменение из $Log^i[s]$ неравно изменению из $Log^i[s]$. Тогда существовал некоторый момент времени, в который либо изменение $Log^i[s]$, либо изменение $Log^j[s]$ оказалось у честного участника, отсюда по следствии из Лемме 3 получаем, что в конечном итоге это изменение должно было оказаться в слоте $s$ у всех честных участников.

Свойство самоконсистентности очевидно, так как в описанном алгоритме изменения не удаляются из лога применений и не модифицируются, а только добавляются в него. $\square$

\section{Прогресс алгоритма}
\noindent Следующее свойство~--- это свойство \textit{прогресса} (Liveness) \cite{hybrid-consensus}:
пусть честный участник получил транзакцию во время $t$, тогда данная транзакция будет добавлена в хранилище всеми \textit{честными} участниками не позднее $t + T_{confirm}$.

Данное свойство использует параметр $T_{confirm}$, предполагается что данный параметр постоянен на протяжении всего времени и известен зараннее.

\section{Отзывчивость алгоритма}

\section{Честность реконфигурации}

\section{Анализ необходимого размера комитета}

\section{Анализ устойчивости к атаке двойной траты}

\section{Анализ устойчивости к атаке эгоистичного майнинга}