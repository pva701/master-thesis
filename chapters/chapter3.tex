%-*-coding: utf-8-*-

\chapter{Анализ предложенного алгоритма}  \label{chapter3}

\section{Модель и определения}
Прежде всего опишем модель, в которой будут проводиться следующие рассуждения, доказательства лемм и теорем.

Определим \textit{события} в системе. Событиями будем считать:
\begin{itemize}
\item отправку сообщения
\item получение сообщения
\item запуск таймера
\item остановку таймера
\end{itemize}

Будем считать, что событие отправки сообщения происходит до его получения, запуска таймера до его остановки, а также, что события одного участника могут быть линейно упорядочены.

В итоге мы получили систему на основе событий с полным порядком. В данной системе можно ввести понятие \textit{согласованного среза}\cite{cons_cut}. Также введем в данной системе глобальное время. Каждому событию в системе можно сопоставить некоторый глобальный момент времени, причем будем считать, что двум событиям одного участника соответствуют разные моменты времени. Заметим, что все события, которые произошли до некоторого момента времени $t$, образуют согласованный срез. Таким образом, если некоторое утверждение верно для любого среза, то оно также верно и для всех событий до момента времени $t$.

Прежде всего, каждый участник имеет состояние, которое включает следующие переменные соответствующих типов:
\begin{itemize}
\item \texttt{leaderChange :: Bool}
\item \texttt{proposed :: Map (ConfigurationdId, LeaderId, SlotId) Propose}
\item \texttt{acceptance :: Vector PrepareCertificate}
\item \texttt{Log      :: Vector CommitCertificate}
\item \texttt{c          :: ConfigurationId}
\item \texttt{v          :: LeaderId}
\item \texttt{Q         :: Set (Puzzle, PublicKey, Nonce, Signature)}
\end{itemize}
Семантическое значение всех переменных можно узнать в предыдущей главе.

Обозначим состояние $i$-го участника в момент времени $t$ как $S_i(t)$, а состояние всей системы $S(t)$. 
$S(t)=\{S_1(t), S_2(t),..., S_{3f+1}(t)\}$. Также введем обозначение $variable^i(t)$ значение переменной $variable$ у участника $i$ в момент времени $t$.
Обозначим состояние $i$-го участника в согласованном срезе $C$ как $S_i(C)$, аналогично $S(C)$ и $variable^i$.
Если $S^i$, $S$ и $variable^i(t)$ используется без указания времени или среза, то предполагается, что $t$ или $C$ ясны из контекста, либо для любых $t$ и $C$.

Будем считать, что честные участники изменяют их состояния согласно описанному алгоритму, в то время как нечестные могут изменять произвольно.
В рамках данного анализа будем считать, что злоумышленнику требуется время $\tau$ для того, чтобы скомпрометировать  честного участника \cite{hybrid-consensus}. При этом $\tau$ значительно больше времени, которое один виртуальный участник находится в комитете $\tau >> nD$.

Будем обозначать долю вычислительных мощностей нечестных участников как $0 \le p \le 1$. Будем также считать, что вероятность найти решение пазла злоумышленником пропорциональна этой доле, и также составляет $p$. 

Вероятность выбрать нечестного участника среди $n$ составляет $\frac{k}{n}$, где $k$~--- это количество нечестных участников. Будем обозначать эту вероятность как $\eta$, $\eta \le \frac{f}{3f+1}$.
\vspace{10pt}

Обозначим за $\bar{\delta}$ среднее время доставки сообщения от одного честного участника другому. 

\textit{Определение.} Будем называть изменение $d$ \textit{оседлым} в слоте $s$, если у как минимум $f+1$ честного участника $acceptance_s$~--- это корректный сертификат согласия для $(c, v, s, d)$.

\textit{Определение.} Будем считать, что честный участник $i$ находится в \textit{состоянии смены лидера}, если $leaderChange^i = True$.

\textit{Определение.} Будем считать, что честный участник $i$ находится в \textit{устойчивом состоянии}, если $leaderChange^i = False$.

\textit{Определение.} Состояние системы $S$ называется \textit{устойчивым состоянием}, если не более $f$ честных участников находятся в состоянии смены лидера. 
%и как минимум $f+1$ честных участников, находящихся в устойчивом состоянии, имеют одинаковое значение $(c^i, v^i)=(c,v)$.

Будем говорить \textit{устойчивое состояние $(c, v)$}, имея ввиду $(c, v)$ из определения.

Если система или участник не находится в устойчивом состоянии, будем говорить, что они находится в \textit{неустойчивом} состоянии.

\textit{Определение.} Будем называть две транзакции \textit{конкурентными}, если их адрес отправителя и $nonce$ равны соответственно.

\section{Базовые свойства}
В данном разделе будут доказаны некоторые базовые свойства, который будут использоваться в дальнейшем.

\textbf{\textit{Свойство 1.}} \textit{Весь жизненный цикл системы разбивается на последовательность времен
$T_0 < T_1 < T_2 < T_3 < ...$, $T_0=0$, где в полуинтервалах $[T_{2k}...T_{2k+1})$ система находится в устойчивом состоянии, а в полуинтервалах $[T_{2k+1}...T_{2k+2})$ в неустойчивом.}
Это очевидно следует из того, что количество участников, который находятся в состоянии смены лидера либо не больше $f$, либо больше $f$. $\square$.
\vspace{10pt}

\textbf{\textit{Свойство 2.}} \textit{Значение $(c^i, v^i)$ не убывает со временем.}
Это очевидно следует из того, что на протяжении алгоритма, значения $с$ и $v$ только увеличиваются. $\square$.
\vspace{10pt}

\textbf{\textit{Свойство 3.}} \textit{В любой момент времени не может существовать более одного сертификата согласия с одинаковой тройкой значений $(c, v, s)$, но для разных изменений.} 

Предположим, что существуют два сертификата согласия $\mathcal{P}_1$ и $\mathcal{P}_2$ с одинаковыми $(c, v, s)$, но разыми $d_1$ и $d_2$. 
Обозначим за $A$ множество участников отправивших $Prepare$ сообщения для  $\mathcal{P}_1$ ($|A|=2f+1$), за $B$ ($|B|=2f+1$) сообщения для $\mathcal{P}_2$. $|A \cap B| \ge f+1$, отсюда следует, что в пересечении найдется как минимум один честный участник, обозначим его за $x$. Получаем, что $x$ отправил два $Prepare$ сообщения с разными $d_1$ и $d_2$, но одинаковыми $(c, v, s)$. Однако, это противоречит проверке 1.1 из раздела \ref{steady-state}. $\square$
\vspace{10pt}

\textbf{\textit{Свойство 4.}} \textit{В каждом устойчивом состоянии существует такой согласованный срез $C$, для которого выполняется, что у всех честных участников, кроме может быть $f$ из них, $s^i$ равны некоторому значению $s$ и $acceptance^i_s$ одинаковы.}

Это очевидно верно для устойчивого состояния $[T_0...T_1)$, срез $C$ можно взять по $T_0$.

Рассмотрим некоторое устойчивое состояние, а также предыдущее ему состояние смены лидера.
Если хотя бы у одного честного участника $i$ значение $leaderChange$ стало $True$, это значит, что он получил сам и отправил другим $\mathcal{W}$. Получая $\mathcal{W}$, участник актуализирует лог вплоть до $s^{*}$ и присваивает $acceptance_{s_P^{*}} := \hat{\mathcal{P}}^{*}$. Если в какой-то момент времени, состояние стало устойчивым, значит у не более чем $f$ честных участников $leaderChange = False$, следовательно, для остальных существовал такой момент времени $t_i$, в который $s^i$ был равен $s^{*}$ и $acceptance_{s_P^{*}}$ равен $\hat{\mathcal{P}}^{*}$. Возьмем эти моменты времени $t_i$ в качестве среза $C$. $\square$
\vspace{10pt}

\textbf{\textit{Свойство 5.}} \textit{В ожидаемое время добавления изменения в $Log$ составляет $5\bar{\sigma}+5\eta(\Delta-\bar{\sigma})+(6\Delta+11\bar{\sigma})\frac{\eta^2}{1-\eta}$}

Вероятность, что лидер честный $1-\eta$, в этом случае ожидаемое время будет $5\bar{\sigma}(1-\eta)$.

Вероятность того, что лидер нечестный $\eta$, тогда он подождет $5\Delta$, до тех пор пока система не перейдет в состояние смены лидера. В состоянии смены лидера, худший случай, если каждый раз $L(c, v')$~--- нечестный и он задерживает следующего лидера на $6\Delta$, ожидаемое время этой задержки~--- не превосходит $6\Delta(\eta^2+\eta^3....)$, далее лидером становится честный участник, который становится лидером и применяет изменение за ожидаемое время $(6\bar{\sigma}+5\bar{\sigma})(\eta^2+\eta^3....)$. В сумме получаем
$$5\bar{\sigma}(1-\eta)+5\Delta\eta+6\Delta\frac{\eta^2}{1-\eta}+11\bar{\sigma}\frac{\eta^2}{1-\eta}=5\bar{\sigma}+5\eta(\Delta-\bar{\sigma})+(6\Delta+11\bar{\sigma})\frac{\eta^2}{1-\eta}$$
$\square$
\vspace{10pt}

\textbf{\textit{Свойство 6.}} \textit{Если количество нечестных участников в комитете $f$, тогда ожидаемое время добавления изменения не превосходит $\frac{31}{6}\bar{\sigma}+\frac{8}{3}\Delta$.}

Данная формула получается приравниванием $\eta = \frac{1}{3}$, так как $\frac{f}{3f+1} < \frac{1}{3}$.  $\square$

\section{Консистентность алгоритма}
В данном разделе будет дано определение \textit{консистентности} (Consistency)\cite{hybrid-consensus} и доказано, что предложенный алгоритм обладает этим свойством.

Будем считать, что алгоритм обладает свойством \textit{общего префикса}, если в любой момент для любых двух честных участников комитета (возможно одного и того же) $i$ и $j$ выполняется: либо $Log^i$ префикс $Log^j$, либо $Log^j$ префикс $Log^i$. Считаем, что $x$ префиксом самого себя и $\emptyset$ префиксом $x$.

Будем считать, что честный участник удовлетворяет свойству \textit{самоконсистентности}, если выполняется: пусть участник честный во время $t$ и $t' \ge t$, $Log$~--- лог в момент времени $t$, $Log'$~--- в момент времени $t'$, тогда верно, что $Log$ префикс $Log'$.

Будем называть алгоритм \textit{консистентным}, если для него выполняется свойство общего префикса и для любого участника выполняется свойство самоконсистентности.
 
Далее будет приведено доказательство консистентности предложенного алгоритма.

\textbf{\textit{Лемма 1.}} \textit{В любой момент времени для любого слота $s$ существует не более одного оседлого изменения $d$.}

Предположим, что существуют два оседлых изменения $d_1$ и $d_2$ в слоте $s$. Рассмотрим сертификат согласия $\mathcal{P}_1$ любого участника для $d_1$ и сертификат согласия $\mathcal{P}_2$ любого участника для $d_2$. Обозначим за $(c_1, v_1)$ значения $c$ и $v$ из первого сертификата, и $(c_2, v_2)$ из второго.

Обозначим за $A$ множество участников отправивших $Prepare$ сообщения для  $\mathcal{P}_1$ ($|A|=2f+1$), за $B$ ($|B|=2f+1$) сообщения для $\mathcal{P}_2$. $|A \cap B| \ge f+1$, отсюда следует, что в пересечении найдется как минимум один честный участник,  обозначим его за $x$. Получаем, что $x$ отправил два $Prepare$ сообщения с разными $d_1$ и $d_2$: одно с $(c_1, v_1, s)$ и второе с $(c_2, v_2, s)$.

Допустим, что $c_1 = c_2$ и $v_1 = v_2$. Тогда получаем противоречие со Свойством 3.

Допустим теперь, что $c_1 < c_2$. Это бы значило, что $x$ между отправками $Prepare$ сообщений должен был перейти в другую конфигурацию. Сделать он это может только добавив в свой лог $\mathcal{C}$ с $d_{rec}$, тем самым увеличив свое значение слота, но тогда бы он не смог отправить второе $Prepare$ сообщение для того же самого $s$, что и первое. Аналогично для случая $c_2 < c_1$.

Допустим теперь, что $c_1=c_2=c$ и $v_1 < v_2$. Пусть $\mathcal{P}_1$ стал оседлым первым в момент времени $T$. Пусть на данный момент в последнем участнике, принявшим $\mathcal{P}_1$ значение конфигурации и номера лидера были $(c, v^i) < (c, v_2)$, тогда в следующем устойчивом состоянии $d_1$ должно быть применено в лог изменений как минимум у $f+1$ участников, и соответственно, их значение слота будет больше $s$, что не позволит им отправить $Prepare$ сообщение для $s$. $\square$
\vspace{10pt}

\textbf{\textit{Лемма 2.}} \textit{Если изменение $d$ стало оседлым в $s$ в устойчивое состояние то $(c, v)$ сертификата согласия строго больше $(c^j, v^j)$ сертификата согласия для неоседлого в слоте $s$ изменения $d'$ ($d \ne d'$).}

Если изменение стало оседлым в устойчивом состоянии, то это значит, что как минимум у $f+1$ честного участника $(c^i, v^i)$ равно значению в сертификате $(c, v)$. И так как $(c^i, v^i)$ увеличивается со временем по Свойству 2, все предыдущие сертификаты согласия имеют $(c^j, v^j)$ меньше либо равное $(c^i, v^i)$, но $(c^j, v^j)$ не может быть равно $(c^i, v^i)$ так как это бы противоречило Свойству 3.
$\square$
\vspace{10pt}

\textbf{\textit{Лемма 3.}} \textit{Если в некоторый момент времени $T$ для слота $s$ существует некоторое оседлое изменение $d$, то данное изменение в конечном счете окажется в логе применения всех честных участников в слоте $s$.}

Пускай не теряя общности, $t \le T$~--- это первый момент времени, в который $d$ стало оседлым в $s$.

Пусть в момент времени $t$ система находится в устойчивом состоянии. Чтобы оставаться в нем, лидер  должен за некоторое ограниченное время отправить как минимум $f+1$ честным участникам $\mathcal{C}$ для $s, d$, иначе же система перейдет в состояние смены лидера. Отметим, что у лидера нет другой опции, кроме как уведомить минимум $f+1$ честных участников о $\mathcal{С}$ для $s, d$, потому что $f+1$ честный участник ожидает только его, так как они получили $\mathcal{P}$ и отправили свое $Commit$ сообщение.

Если существуют как минимум $f+1$ честных участников, которые имеют $\mathcal{C}^i$ для слота не меньшего чем $s$, тогда очередная процедура реконфигурации распространит среди всех честных участников некоторый $\mathcal{C}'$ со слотом большим $s$. Таким образом, честные участники, для которых неизвестен $\mathcal{С}$ для $s, d$, смогут получить его в процедуре актуализации логов на шаге 3.3 реконфигурации.

Теперь рассмотрим случай, когда в момент времени $T$ система находится в состоянии смены лидера ($T_{2k+1} \le T < T_{2k+2}$). Не теряя общности, возьмем наименьшее такое $T$, для которого все еще выполняется $T_{2k+1} \le T < T_{2k+2}$.

Если $T= T_{2k+1}$, то есть изменение $d$ было оседлым в $s$ с $\mathcal{P}$ для $(c, v)$ до начала состояния смены лидера, тогда в сертификате $\mathcal{W}$, полученном для следующего устойчивого состояния, $\mathcal{P}^{*}$ неизбежно будет для $c, v, s, d$, так как для формирования $Election$ сообщения необходимо как минимум $2f+1$ $LeaderChange$ сообщение, следовательно, обязательно присутствие как минимум одного $\mathcal{P}$ для $c, v, s, d$. Также принимаем во внимание, что по Лемме 1 не может существовать другого оседлого значения, и по Лемме 2 любой другой сертификат имеет $(c^j, v^j)$ меньшее, чем $(c, v)$. С другой стороны, система не перейдет в новое устойчивое состояние до тех пор, пока как минимум $f+1$ честный участник не получит $\mathcal{C}$ для $s, d$. Учитывая то, что среди $f+1$ лидеров, которым отправят $LeaderChange$, будет как минимум один честный, рано или поздно это произойдет. А далее по уже описанному случаю.

Если же  $T > T_{2k+1}$, это означает, что $d$ могло стать оседлым только на шаге 3.5 процедуры смены лидера. Тогда в следующем устойчивом состоянии как минимум $f+1$ честный участник будет иметь сертификат $acceptance_s = \mathcal{P}^{*}$, и следовательно, как минимум $f+1$ честный будут иметь $\mathcal{C}$ для $s, d$. А далее доказательство для уже описанного выше случая.
$\square$
\vspace{10pt}

\textit{Следствие из Леммы 3.} Если хотя бы один честный участник имеет сертификат применения $\mathcal{C}$ для изменения $d$, то  изменение $d$ неизбежно окажется в логе применения всех честных участников в слоте $s$. 

Это следует из того, что как минимум $f+1$ честных участников, отправивших $Commit$ сообщение для $\mathcal{C}$, имеют сертификат согласия для $d$ и $s$. $\square$
\vspace{10pt}

\textbf{Теорема.} \textit{В любой момент времени логи честных участников консистентны.}

Предположим, что в некоторый момент времени существуют различные участники $i$ и $j$, такие что, существует $s$, для которого выполняется, что изменение из $Log^i_s$ неравно изменению из $Log^i_s$. Тогда существовал некоторый момент времени, в который либо изменение $Log^i_s$, либо изменение $Log^j_s$ оказалось у честного участника, отсюда по следствии из Лемме 3 получаем, что в конечном итоге это изменение должно было оказаться в слоте $s$ у всех честных участников.

Свойство самоконсистентности очевидно, так как в описанном алгоритме изменения не удаляются из лога применений и не модифицируются, а только добавляются в него. $\square$

\section{Прогресс алгоритма}
\noindent Следующее свойство~--- это свойство \textit{прогресса} (Liveness) \cite{hybrid-consensus}:
пусть клиент получил для транзакции сертификат обещания во время $\hat{t}$, тогда данная транзакция будет добавлена в $Log$ как минимум $f+1$ честным участникам не позднее $\hat{t} + T_{confirm}$.

Данное свойство использует параметр $T_{confirm}$, предполагается что данный параметр постоянен на протяжении всего времени и известен заранее.

Вообще говоря, транзакция может быть и не добавлена в лог изменений, до нее туда попала конкурентная транзакция. Поэтому все леммы в данном разделе будут доказаны для транзакций, которые остаются корректными от получения сертификата обещания и до попадания в $Log$.
\vspace{10pt}

\textbf{\textit{Лемма 4.}} \textit{Если в интервале $[\hat{t}...\hat{t}+12\Delta]$ лидер честный, тогда $T_{confirm} \le 12\Delta$.}

Если лидер честный в данном интервале, значит он не мог привести систему к изменению лидера.

Пусть сертификат для транзакции $tx$ был получен клиентом в $\hat{t}$, тогда
в момент времени $\hat{t}+\Delta$ $tx$ гарантированно была в его мемпуле. В данный момент уже мог быть предложен $Propose$, содержащий изменение не включающее $tx$. Для того чтобы это изменение попало в лог, должно пройти не более $5\Delta$. Если данное изменение был микроблок, то в следующий микроблок должна гарантировано попасть $tx$, который применится не позже чем за $5\Delta$.
Если же изменение было $d_{rec}$, то новый лидер должен узнать о транзакции $tx$ не позднее чем через $\Delta$. И следующий микроблок должен содержать $tx$.
Итого, складываем времена в худшем случае, когда в между получением сертификата обещания и попаданием транзакции в лог $f+1$ честных участников могла произойти реконфигурация, получаем $T_{confirm} \le \Delta + 5\Delta+\Delta+5\Delta=12\Delta$. $\square$
\vspace{10pt}

\textbf{\textit{Лемма 5.}}  \textit{Если в интервале $[\hat{t}...\hat{t}+12\Delta]$ лидер честный, тогда ожидаемое время $T_{confirm}$ не превышает $10\bar{\delta}$.}

Обозначим как $\bar{T}_{confirm}$~--- ожидаемое время  $T_{confirm}$.

Пусть ожидаемое время, чтобы добавить в $Log$ изменение в рамках одной конфигурации~--- $\sigma$.
Тогда ожидаемое количество слотов в рамках одной конфигурации $\frac{D}{\sigma}$. Отсюда, вероятность, что в данном слоте добавляется $d_{rec}$~--- $\frac{D}{\sigma}^{-1}$, следовательно, ожидаемое время добавить транзакцию в лог равно: 
$$\bar{T}_{confirm}=\bar{\delta}+\bar{T}_{mempool}+\bar{T}_{apply}$$
где $\bar{T}_{mempool}$~--- среднее время, которое транзакция проведет в мемпуле, которое равно $\frac{5\bar{\delta}}{2}$, $\bar{T}_{apply}$~--- среднее время, которое необходимо, чтобы добавить изменение в лог, которое равно $5\bar{\delta}(1-\frac{\sigma}{D})+6\bar{\delta}\frac{\sigma}{D}=5\bar{\delta}+\bar{\delta}\frac{\sigma}{D}$.
В результате получаем $\bar{T}_{confirm}=\bar{\delta}+\frac{5\bar{\delta}}{2}+5\bar{\delta}+\bar{\delta}\frac{\sigma}{D}=9,5\bar{\delta}+\bar{\delta}\frac{\sigma}{D}$. $\bar{\delta}\frac{\sigma}{D}$ можно оценить сверху как $\frac{\bar{\delta}}{2}$. $\square$
\vspace{10pt}

\textbf{\textit{Лемма 6.}}  \textit{Для любого состояния алгоритма $S(t_1)$, существует момент времени $t_2 \ge t_1$, в котором для всех честных участников $i$ выполняется $s^i(t_1)> s^i(t_2)$.}

Рассмотрим некоторый момент времени $t_1$. Вычислим $s=max(s^i(t_1))$ среди все честных участников. 

По лемме 1, в нем не может быть более одного оседлого изменения для $s$. По лемме 3, если для $s$ существует некоторое оседлое изменение, то наступит такой момент $t_2$, в который оно окажется в логе применения всех честных участников, следовательно $s^i(t_2)> s^i(t_1)$.

Если же для $s$ не существует оседлого изменения, покажем, что неизбежно наступит такой момент $t^o$, когда будет существовать оседлое изменение для слота $s$, а далее по доказанному выше. Для $s-1$ гарантированно существует оседлое значение, по следствию из леммы 3. Опять же, по лемме 3, наступит такой первый момент $t_4$, в который $2f+1$ честных участников добавят его себе в $Log$. Если в $t_4$ уже существует оседлое значения для $s$, то возьмем $t^o=t_4$ и далее по доказанному выше. 

Если момент времени $t_4$, участники находятся в устойчивом состоянии, то лидер либо предложил следующее изменение, которое станет оседлым в этом устойчивом состоянии. Или же произойдет смена лидера.

Во время смены лидера все участники либо получат одинаковый сертификат согласия, который станет оседлым. Либо же $acceptance_s^i$ останется пустым, и тогда мы перейдем к случаю выше.

Рано или поздно, система перейдет к устойчивому состоянию с честным лидером, в котором он предложит изменение и сделает его устойчивым. $\square$
\vspace{10pt}

\textbf{\textit{Лемма 7.}}  \textit{$T_{confirm}$ не превосходит $(f+1)(D+6\Delta f)$.}

Чтобы оценить худшее значение $T_{confirm}$, необходимо проанализировать худший сценарий.

Худший случай, когда нечестный лидер вообще не добавляет транзакцию в свой мемпул и выпускает микроблоки без нее. При этом клиент никак не сообщает о нечестности лидера. Сразу стоит отметить, что нечестному лидеру невыгодно передавать управление честному, потому что он сразу добавит транзакцию в микроблок. Таким образом, ему невыгодно инициировать смену лидера, даже если следующий лидер тоже будет нечестным. Единственный  момент, когда лидеру выгодно инициировать смену лидера~--- когда в следующем слоте необходимо произвести реконфигурацию. На смену лидера максимально можно потратить $6\Delta f$~--- это случай, когда $f-1$ подряд идущих лидеров оказались нечестными, а последний~--- честный.
После чего, новый честный лидер должен провести реконфигурацию. Если новый нечестный участник нечестный, он проделывает то же самое, дожидается следующей реконфигурации, и так далее. Всего это может произойти не более $f$ раз, иначе в комитете будет содержаться более $f+1$ лидера. Получаем следующую формулу:
$$ T_{confirm} \le (f+1)(D+6\Delta f)$$ $\square$

\textbf{Теорема.} \textit{Если в комитете не более $f$ нечестных участников, то алгоритм обладает свойством прогресса.}

Из леммы 6 следует, что в некоторый момент алгоритм не перестанет прогрессировать. Из леммы 7 же можно видеть, что время, необходимое, чтобы транзакция оказалась в логи применений $T_{confirm}$~--- конечно, и зависит только от неизменных параметров системы, следовательно, может быть вычислено заранее, получаем, что алгоритм обеспечивает прогресс. $\square$

%\section{Отзывчивость алгоритма}

\section{Честность реконфигурации}
В данном разделе будет доказано, что лидер комитета не может задержать реконфигурацию, а также не может предложить желаемых кандидатов.

\textbf{\textit{Лемма 8.}} \textit{Если сертификат кандидата $\mathcal{S}$ для кандидата $W$ и слота $s$ находится в $Q^i$ не менее $f+1$ честных участников, и не существует такого $\mathcal{S}'$, в котором $s' < s$,  то $Log_s$ любого честного участника будет $d_{rec}$, содержащий $W$.}

Покажем, что $\mathcal{S}$ будет существовать в $Q^i$ не менее $f+1$ честных участников до тех пор, пока не произойдет реконфигурация.

Рассмотрим $\mathcal{S}$ для $W$ и $s^{*}$. Пусть $T$ первый момент времени, когда $\mathcal{S}$ появился в $Q$ у $f+1$ честного участника. Следующее изменение $Q$  может произойти либо на шаге 2.4 или 3.8 реконфигурации, либо на шаге 3.3 смены лидера. На шаге 2.4 добавляется новый сертификат, поэтому $\mathcal{S}$ все еще будет в $Q$.  На шаге 3.3 $Q := Q^{*}$, $Q^{*}=\bigcup\limits_{i=1}^{2f+1} Q_i$, но среди $Q_i$ неизбежно должен быть как минимум один $Q^i$ честного участника, содержащего $\mathcal{S}$. Таким образом, $\mathcal{S}$ все еще будет принадлежать $Q$. Последнее место, где может измениться $Q$~--- это шаг 3.8 реконфигурации. Учитывая то, что не существует $\mathcal{S}'$, в котором $s' < s$, то это могло произойти только для $d_{rec}$ со слотом $s$. С другой стороны, чтобы это произошло на шаге 3.8, необходимо, чтобы как минимум $2f+1$ участника ранее отправили свои $Prepare$, однако, среди этих $2f+1$ гарантировано должен был быть честный, у которого $\mathcal{S}$ все еще в $Q$. Учитывая то, что к проверкам 1.1 из раздела $\ref{steady-state}$, добавляется проверка наличия $W$ в $d_{rec}$, получаем что $d_{rec}$ для слота $s$ содержит $W$.
$\square$
\vspace{10pt}

Из данной леммы следует, что невозможно предложить $d_{rec}$, который не содержал бы всех $W$, которые известны как минимум $f+1$ честным участникам. То есть нечестный лидер не сможет произвольным образом убрать кандидатов из $d_{rec}$.
\vspace{10pt}

\textbf{\textit{Лемма 9.}}  \textit{Ожидаемое преимущество во времени решения пазла нечестного участника перед честным составляет не более $\frac{31}{6}\bar{\sigma}+\frac{8}{3}\Delta$.}

Нечестный лидер, получив решение пазла от честного участника для слота $s^{*}$, может попытаться отсрочить переход к следующему слоту, так как при наступлении него, новые кандидаты с $s^{*}+1$ уже не попадут в конфигурацию.

Пользуясь свойством 6, которое устанавливает верхнюю границу на добавление изменения в лог, получаем, что ожидаемое время отсрочки не может превышать $\frac{31}{6}\bar{\sigma}+\frac{8}{3}\Delta$. $\square$
\vspace{10pt}

Данная лемма не очень полезна сама по себе, без реальных значений $\bar{\sigma}$ и $\Delta$. В данном случае важно, какой процент в выигрыше во времени получит нечестный участник. Если считать, что честный участник нашел решение пазла за время $D$, которое приблзительно равно 10 минутам (600 секундам), то важно значение отношения $\frac{\frac{31}{6}\bar{\sigma}+\frac{8}{3}\Delta}{D}$ при всех разумных $\bar{\sigma}$ и $\Delta$. \textbf{TODO}

%\section{Необходимый размер комитета}

\section{Анализ устойчивости к атаке двойной траты}
Атака двойной траты производится на системы, где возможна вилка. Сначала проводится транзакция $tx_1$, которая попадает в блокчейн и после нее создается еще несколько блоков. Затем на систему производится атака, DDoS или другая, после которой все эти блоки (в том числе содержащий $tx_1$) откатываются и производится $tx_2$, которая тратит деньги с того же адреса. Таким образом, за время пока блоки не откатились, за переведенные деньги получается товар или фиатные средства, а затем, после отката блоков, деньги выводятся на другой адрес злоумышленника.

Но в отличии от других криптовалют, в предложенном алгоритме не может быть вилок, если количество неисправных участников не превосходит $f$.

\section{Анализ устойчивости к атаке эгоистичного майнинга}
Атака эгоистичного майнинга на системы на основе доказательства выполненной работы может производиться на системы, где $puzzle$ который решают участники, определяется уже решенными пазлами, а также содержанием выпущенных блоков. Потому что нечестный участник может найти решение очередного пазла $puzzle_i$ и не опубликовав его для остальных, продолжить поиск решения уже для следующего пазла $puzzle_{i+1}$, потому что у него есть все необходимые данные для его вычисления. Таким образом, честные участники будут продолжать искать решение для $puzzle_i$, не зная о том, что оно уже найдено и их работа в общем-то бесполезна. Нечестный участник же, сможет начать работу над $puzzle_{i+1}$ раньше, следовательно его влияние будет больше, не пропорционально его доле вычислительной мощности $p$.

В предложенном же алгоритме, каждый следующий $puzzle_{i+1}$ зависит не только от решения предыдущего пазла, но и еще от подписи $f+1$ участниками решения для $puzzle_i$. Среди этих участников будет как минимум один нескомпрометированный  участник, подпись которого невозможно подделать. Поэтому, нечестный участник не имеет возможности получить значение следующего $puzzle_{i+1}$, не опубликовав найденное решение.

Такое решение спасает от эгоистичного майнинга, хотя порождает ситуацию, что у каждого майнера вообще говоря может быть свой уникальный $puzzle_{i+1}$, так как $f+1$ подпись вообще говоря может быть от разных участников. Однако, это не является проблемой, так как в среднем сложность решения каждого такого пазла одинакова.
 
\section{Анализ наличия более f неисправных участников}
В рамках всей работы требовалось, чтобы в комитете было не более $f$ неисправных участников.
В данном разделе будет рассмотрено, что произойдет если их количество станет как минимум $f+1$.

Если в комитете окажутся $f+1$ нечестных участников, которые все действуют сообща. То они могут добиться последовательности смены лидеров, которая приводит комитет к нечестному лидеру. И далее добавить два или более различных изменения в логи честных участников в слот $s$. Используя расхождение логов, можно добиться двойной траты.

Рассмотрим менее критичный случай, когда в комитете $f+1$ участников отключены от сети. В данном случае, ни одно изменение не сможет более добавиться в лог, а также не более чем за время $6\Delta$ система перейдет в состояние смены лидера, из которого не сможет выйти до тех пор, пока один из отключенных участников не вернется в комитет. В данном случае получаем, что логи участников, как и сам комитет будут в стагнации. Еще один спецэффект, что за это конфигурация комитета не будет обновляться, следовательно, не будет обновляться и $puzzle^c$, что приведет к тому, что майнеры будут иметь время на решение пазла до тех пор, пока в комитете снова не будет $2f+1$ честных участников. Но даже в этом случае в комитет добавится только один кандидат, из всех решивших пазл.