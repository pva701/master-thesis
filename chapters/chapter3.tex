%-*-coding: utf-8-*-

\chapter{Анализ предложенного алгоритма}  \label{chapter3}

\section{Модель и определения}
Прежде всего опишем модель, в которой будут проводиться следующие рассуждения, доказательства лемм и теорем.

Определим \textit{события} в системе. Событиями будем считать:
\begin{itemize}
\item отправку сообщения
\item получение сообщения
\item запуск таймера
\item остановку таймера
\end{itemize}

Будем считать, что событие отправки сообщения происходит до его получения, запуска таймера до его остановки, а также, что события в рамках одного участника могут быть линейно упорядоченны.

В итоге мы получили систему на основе событий с полным порядком. В данной системе можно ввести понятие \textit{согласованного среза}[ссылка]. Также введем в данной системе глобальное время. Каждому событию в системе можно сопоставить некоторый глобальный момент времени.

Прежде всего, каждый участник имеет состояние, в которое входят следующие переменные:
\begin{itemize}
\item leaderChange :: Bool
\end{itemize}

Обозначим состояние $i$-го участника в момент времени $t$ как $S_i(t)$, а состояние всей системы $S(t)$. 
$S(t)=\{S_1(t), S_2(t),..., S_{3f+1}(t)\}$. Также введем обозначение $variable^i(t)$ значение переменной $variable$ у участника $i$ в момент времени $t$.
Обозначим состояние $i$-го участника в согласованном срезе $C$ как $S_i(C)$, аналогично $S(C)$ и $variable^i$.
Если $S^i$, $S$ и $variable^i(t)$ используется без указания времени или среза, то предполагается, что $t$ или $C$ ясны из контекста, либо для любых $t$ и $C$.

Будем считать, что честные участники изменяют их состояния согласно описанному алгоритму, в то время как нечестные могут изменять произвольно.

Злые участники \textbf{TODO}.

\textit{Определение.} Будем называть изменение $d$ \textit{оседлым} в слоте $s$, если у как минимум $f+1$ честного участника $acceptance_s$~--- это корректный сертификат согласия для пары $(s, d)$.

\textit{Определение.} Будем считать, что честный участник $i$ находится в \textit{состоянии смены лидера}, если $leaderChange^i = True$.

\textit{Определение.} Будем считать, что честный участник $i$ находится в \textit{устойчивом состоянии}, если $leaderChange^i = False$.

\textit{Определение.} Состояние системы $S$ называется \textit{устойчивым состоянием}, если не более $f$ честных участников находится в состоянии смены лидера.

Если система или участник не находится в устойчивом состоянии, будем говорить, что они находится в \textit{неустойчивом} состоянии.

\section{Базовые свойства}
В данном разделе будут доказаны некоторые базовые свойства, который будут использоваться в дальнейшем.

\textbf{\textit{Свойство 1.}} Весь жизненный цикл системы разбивается на последовательность времен
$t_0 \le T_1 \le T_2 \le T_3 \le ...$, $T_0=0$, где в полуитервалы времени $[T_{2k}...T_{2k+1})$ система находится в устойчивом состоянии, а в полуинтервалы $[T_{2k+1}...T_{2k+2})$ в неустойчивом.

\textbf{\textit{Лемма 1.}} \textit{В каждом устойчивом состоянии существует такой согласованный срез $C$, для которого выполняется, что у всех честных участников, кроме может быть $f$ из них, $s^i$ равны некоторому значению $s$ и $acceptance^i_s$ одинаковы.}

Это очевидно верно для устойчивого состояния $[T_0...T_1)$, срез $C$ можно взять по $T_0$.

Рассмотрим некоторое устойчивое состояние, а также предыдущее ему состояние смены лидера.
Если хотя бы у одного честного участника $i$ значение $leaderChange$ стало $True$, это значит, что он получил сам и отправил другим $\mathcal{W}$. Получая $\mathcal{W}$, участник актуализирует лог вплоть до $s^{*}$ и присваивает $acceptance_{s_P^{*}} := \hat{\mathcal{P}}^{*}$. Если в какой-то момент времени, состояние стало устойчивым, значит у не более чем $f$ честных участников $leaderChange = False$, следовательно, для остальных существовал такой момент времени $t_i$, в который $s^i$ был равен $s^{*}$ и $acceptance_{s_P^{*}}$ равен $\hat{\mathcal{P}}^{*}$. Возьмем эти моменты времени $t_i$ в качестве среза $C$. $\square$

\section{Консистентность алгоритма}
В данном разделе будет дано определение \textit{консистентности} (Consistency)\cite{hybrid-consensus} и доказано, что предложенный алгоритм обладает этим свойством.

Будем считать, что алгоритм обладает свойством \textit{общего префикса}, если в любой момент для любых двух честных участников комитета (возможно одного и того же) $i$ и $j$ выполняется: либо $Log_{C_i}$ префикс $Log_{C_j}$, либо $Log_{C_j}$ префикс $Log_{C_i}$. Считаем, что $x$ префиксом самого себя и $\emptyset$ префиксом $x$.

Будем считать, что честный участник удовлетворяет свойству \textit{самоконсистентности}, если выполняется: пусть участник честный во время $t$ и $t' \ge t$, $Log_{C_i}$~--- лог в момент времени $t$, $Log'_{C_i}$~--- в момент времени $t'$, тогда верно, что $Log_{C_i}$ префикс $Log'_{C_i}$.

Будем называть алгоритм \textit{консистентным}, если для него выполняется свойство общего префикса и для любого участника выполняется свойство самоконсистентности.
 
Далее будет приведено доказательство консистентности предложенного алгоритма.

\textbf{\textit{Лемма 1.}} \textit{В любой момент времени для любого слота $s$ существует не более одного оседлого изменения $d$.}

Предположим, что существуют два оседлых изменения $d_1$ и $d_2$ в слоте $s$. Рассмотрим сертификат согласия $\mathcal{P}_1$ любого участника для $d_1$ и сертификат согласия $\mathcal{P}_2$ любого участника для $d_2$. Обозначим за $(c_1, v_1)$ значения $c$ и $v$ из первого сертификата, и $(c_2, v_2)$ из второго.

Обозначим за $A$ множество участников отправивших$Prepare$ сообщения для  $\mathcal{P}_1$ ($|A|=2f+1$), за $B$ ($|B|=2f+1$) сообщения для $\mathcal{P}_2$. $|A \cap B| \ge f+1$, отсюда следует, что в пересечении найдется как минимум один честный участник,  обозначим его за $x$. Получаем, что $x$ отправил два $Prepare$ сообщения с разными $d_1$ и $d_2$: одно с $(c_1, v_1, s)$ и второе с $(c_2, v_2, s)$.

Допустим, что $c_1 = c_2$ и  $v_1 = v_2$. Тогда получаем противоречие с проверками 1.1 из раздела \ref{steady-state}.

Допустим теперь, что $c_1 < c_2$. Это бы значило, что $x$ между отправками $Prepare$ сообщений должен был бы перейти в другую конфигурацию, сделать он это может только добавив в свой лог $\mathcal{C}$ с $d_{rec}$, тем самым увеличив свое значение слота, но тогда бы он не смог отправить второе $Prepare$ сообщение для того же самого $s$, что и первое. Аналогично для случая $c_2 < c_1$.

Допустим теперь, что $c_1=c_2$ и $v_1 < v_2$. Так как $v_1 < v_2$, то должна была произойти смена лидера и переход в новое устойчивое состояние, в котором не более $f$ честных участников, у которых текущий слот $s$, и у остальных участников текущий слот больше $s$. Отсюда следует, что в сертификат для  $\mathcal{P}_2$ не может содержать $2f+1$ сообщений со слотом $s$, так как это противоречит проверкам 1.1 из раздела \ref{steady-state}.  Получили невозможность существования $\mathcal{P}_2$~--- противоречие. Аналогично для случая $v_2 < v_1$.
$\square$

\textbf{\textit{Лемма 2.}} Если в некоторый момент времени для слота $s$ существует некоторое оседлое изменение $d$, то данное изменение в конечном счете неизбежно окажется в логе применения всех честных участников в слоте $s$.

Ра
TODO $\square$

\vspace{10pt}

\textit{Следствие из Леммы 1.} Если хотя бы один честный участник имеет сертификат применения $\mathcal{C}$ для изменения $d$ соответствующему слоту $s$, то  изменение $d$ неизбежно окажется в логе применения всех честных участников в слоте $s$. 

Так как, из того что участник имеет $\mathcal{C}$, следует что как минимум $f+1$ честных участников отправили $Commit$ сообщение, имея сертификат согласия для $d$ и $s$. $\square$
\vspace{10pt}

\textbf{Теорема.} \textit{В любой момент времени логи честных участников консистентны.}

Предположим, что в некоторый момент времени существуют различные участники $i$ и $j$, такие что, существует $s$, для которого выполняется, что изменение из $Log_{C_i}[s]$ неравно изменению из $Log_{C_j}[s]$. Тогда существовал некоторый момент времени, в который либо изменение $Log_{C_i}[s]$, либо изменение $Log_{C_j}[s]$ было оседлым, отсюда по Лемме 2 получаем, что только это изменение могло оказаться в слоте $s$ у всех честных участников. Получили противоречие.

Свойство самоконсистентности очевидно, так как в описанном алгоритме изменения не удаляются из лога применений и не модифицируются, а только добавляются в него. $\square$

\section{Прогресс алгоритма}
\noindent Следующее свойство ~--- это свойство \textit{прогресса} (Liveness) \cite{hybrid-consensus}:
пусть честный участник получил транзакцию во время $t$, тогда данная транзакция будет добавлена в хранилище всеми \textit{честными} участниками не позднее $t + T_{confirm}$.

Данное свойство использует параметр $T_{confirm}$, предполагается что данный параметр постоянен на протяжении всего времени и известен зараннее.

\section{Отзывчивость алгоритма}