%-*-coding: utf-8-*-

\chapter{Анализ предложенного алгоритма}  \label{chapter3}

\section{Свойства алгоритма SMR}
В данном разделе мы обозначим свойства, которые должен предоставлять SMR алгоритм. В следующих разделах докажем, что эти свойства выполняются для предложенного алгоритма.

Первое из таких свойств \textit{консистентность} (Consistency)\cite{hybrid-consensus}, включает в себя:
\begin{itemize}
\item \textbf{Общий префикс}. В любой момент для любых двух честных участников комитета (возможно одного и того же) $i$ и $j$  выполняется: либо $Log_{C_i} \prec Log_{C_j}$, либо $Log_{C_j} \prec Log_{C_i}$. Оператор $\prec$ означает <<являться префиксом>>. Считаем, что $x \prec x$ и $\emptyset \prec x$.
\item \textbf{Самоконсистентность}. Пусть участник $i$ честный во время $t$ и $t' \ge t$, $Log_{C_i}$~--- лог в момент времени $t$, $Log'_{C_i}$~--- в момент времени $t'$, тогда верно, что $Log_{C_i} \prec Log'_{C_i}$
\end{itemize}

\noindent Следующее свойство ~--- \textit{живучесть} (Liveness) \cite{hybrid-consensus}:
пусть честный участник получил транзакцию во время $t$, тогда данная транзакция будет добавлена в хранилище всеми \textit{честными} участниками не позднее $t + T_{confirm}$.

Данное свойство использует параметр $T_{confirm}$, предполагается что данный параметр постоянен на протяжении всего времени и известен зараннее.

TODO отзывчивость

\section{Доказательство консистентности алгоритма}
Лемма 1. Для любых $c$, $v$ и $s$ любой честный участник может отправить не более одного $Prepare$ и $Commit$ сообщения.

TODO $\square$.

\textbf{Теорема.} \textit{В любой момент времени логи честных участников консистентны.}

Докажем самоконсистентность от противного.

Предположим, что в некоторый момент времени $t$ существуют различные участники $i$ и $j$, такие что, существует $s$, для которого выполняется $Log_{C_i}[s] \neq Log_{C_j}[s]$.

Обозначим за $\mathcal{C}^i$ $Log_{C_i}[s]$, $c_i$ и $v_i$ значения $c$, $v$ и $d_i$ из $\mathcal{C}^i$. $\mathcal{C}^j$, $c_j$, $v_j$ и $d_j$ для $j$ соответственно. Для определенности, пусть $(c_i, v_i) \ge (c_j, v_j)$.

\textit{Cлучай 1.} $c_i=c_j$, $v_i = v_j$. 

Рассмотрим участников, которые прислали свои $Commit$ сообщения для сертификатов $\mathcal{C}^i$ и $\mathcal{C}^j$. Среди них не более $f$ неисправных, следовательно в каждом сертификате как минимум $f+1$ честных, отсюда следует по принципу Дирихле, что как минимум один честный участник отправил свои $Commit$ и $Prepare$ сообщения для разных $d_i$ и $d_j$ в рамках одного $(c_i, v_i)$, что противоречит Лемме 1.
\vspace{10pt}

\textit{Cлучай 2.} $c_i=c_j$, $v_i > v_j$. Так как $v_i > v_j$, то должна была произойти смена лидера, то есть $2f+1$ участник должны были отправить $\langle LeaderChange, c_i, v_i,  \hat{\mathcal{P}}, Q_{c_i} \rangle_M$. Так как у $j$ имеется сертификат применения для $d_j$, это значит, что у $f+1$ честных участников